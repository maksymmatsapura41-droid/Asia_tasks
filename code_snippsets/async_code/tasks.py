# 1.
# Сценарий:
# Ты пишешь логгер, который сохраняет важные данные в файл.
# Задача: Напиши корутину save_data(), которая имитирует долгую запись (3 секунды через asyncio.sleep).
# Если задачу отменяют (CancelledError), она должна успеть вывести в консоль: "Завершаю критическую запись ресурсов...".
# В main запусти эту задачу, оберни её в asyncio.shield() и через 1 секунду отмени внешнюю обертку.
# Убедись, что сама запись всё равно дошла до конца.
# 2.
# Сценарий:
# Твой микросервис запрашивает данные у внешнего API. З
# адача: Создай корутину fetch_api(), которая спит случайное время от 1 до 10 секунд.
# В main вызови её, установив жесткий таймаут в 5 секунд через asyncio.wait_for.
# Если API не ответило вовремя — выведи "Сервис недоступен, пробуем позже", если ответило — "Данные получены".
# 3.
# Сценарий:
# В Python 3.11+ появился asyncio.timeout_at.
# Представь, что у тебя есть процесс, который должен строго завершиться до определенного момента времени в будущем.
# Задача: Получи текущее время цикла через loop = asyncio.get_running_loop(); now = loop.time().
# Установи дедлайн на now + 3 секунды.
# Внутри контекстного менеджера timeout_at запусти цикл, который печатает "Работаю..." каждую секунду.
# Проверь, как контекстный менеджер прервет цикл.
# 4.
# Сценарий:
# Ты парсишь 5 разных сайтов.
# Тебе не важно, в каком порядке они придут - ты хочешь обрабатывать их по мере готовности.
# Задача: Создай список из 5 корутин, каждая из которых спит случайное время и возвращает свое имя (например, "Сайт 1", "Сайт 2").
# Используй asyncio.as_completed, чтобы перебирать результаты в цикле for и печатать их сразу, как только они "прилетают".
# 5.
# Сценарий:
# Твой асинхронный сервер должен генерировать PDF. Библиотека для PDF (предположим, ReportLab) - синхронная и очень тяжелая.
# Задача: Напиши обычную функцию CPU_heavy_task(n), которая считает сумму квадратов чисел до n (возьми n=10**7) через обычный цикл for.
# Сначала вызови её просто так в async функции и посмотри, как она блокирует всё.
# Затем оберни её в asyncio.to_thread и убедись, что пока идет расчет, ты можешь параллельно печатать в консоль "Я не завис!"
# каждые 0.5 сек.
# 6.
# Задача:
# Напиши программу, которая:
# Запускает синхронную функцию чтения файла через to_thread.
# Ограничивает время выполнения этой операции через wait_for (например, 2 секунды).
# Если чтение файла не успело - корректно обрабатывает TimeoutError и пишет: "Файл слишком большой для чтения в этом потоке".